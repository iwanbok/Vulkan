// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)

#version 450

layout (local_size_x = 32, local_size_y = 32) in;
layout (binding = 0, rgba8) uniform image2D resultImage;

#define EPSILON 0.0001
#define MAXLEN 1000.0
#define MAXBOUNCES 5
#define BLACK vec3(0)
#define WHITE vec3(1)
#define PI 3.14159265358979323846264338327950288419716939937510582097494459072381640628620899862803482534211706798f
#define UINT_MAX 0xffffffffu

struct Camera 
{
	vec3 pos;   
	vec3 lookat;
	float fov; 
};

layout (binding = 1) uniform UBO 
{
	vec3 lightPos;
	float aspectRatio;
	vec2 fogColor;
	uint seed;
	uint samples;
	Camera camera;
} ubo;

uint state = 0;

uint xorshift32()
{
	/* Algorithm "xor" from p. 4 of Marsaglia, "Xorshift RNGs" */
	uint x = state;
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	state = x;
	return x;
}

float floatConstruct( uint m ) 
{
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

float frand()
{
	return floatConstruct( xorshift32() );
}


/*struct Sphere 
{
	vec3 pos;
	float radius;
	vec3 diffuse;
	float specular;
	int id;
};

struct Plane
{
	vec3 normal;
	float distance;
	vec3 diffuse;
	float specular;
	int id;
};

layout (std140, binding = 2) buffer Spheres
{
	Sphere spheres[ ];
};

layout (std140, binding = 3) buffer Planes
{
	Plane planes[ ];
};*/

// Primitive Types
const uint PRIMITIVE_SPHERE = 0x00000001u;
const uint PRIMITIVE_PLANE = 0x00000002u;

// Material Types
const uint MATERIAL_DIFFUSE = 0x00000001u;
const uint MATERIAL_SPECULAR = 0x00000002u;
const uint MATERIAL_DIELICTRIC = 0x00000004u;
const uint MATERIAL_LIGHT = 0x00000008u;

struct Primitive
{
	vec3 v1;
	float f1;
	vec3 v2;
	float f2;
	uint type;
	uint material;
};

layout (std140, binding = 2) buffer Primitives
{
	Primitive primitives[ ];
};

struct Ray
{
	vec3 O;
	float n1;
	vec3 D;
};

float sphereIntersect( Ray r, Primitive sphere )
{
	vec3 oc = r.O - sphere.v1;
	float b = 2.f * dot( oc, r.D );
	float c = dot( oc, oc ) - sphere.f1 * sphere.f1;
	float D = b * b - 4.f * c;

	if ( D < 0.f )
		return -1;

	float t = ( -b - sqrt( D ) ) / 2.f;
	return t;
}

float planeIntersect( Ray r, Primitive plane)
{
	float d = dot( r.D, plane.v1 );

	if ( d == 0.f )
		return -1;

	float t = -( plane.f1 + dot( r.O, plane.v1 ) ) / d;
	return t;
}

float intersect( Ray r, Primitive p)
{
	float t = -1;
	switch(p.type)
	{
	case PRIMITIVE_PLANE:
		t = planeIntersect(r, p);
		break;
	case PRIMITIVE_SPHERE:
		t = sphereIntersect(r,p);
		break;
	}
	return t;
}

vec3 getNormal( Primitive p, vec3 pos )
{
	switch(p.type)
	{
	case PRIMITIVE_PLANE:
		return p.v1;
	case PRIMITIVE_SPHERE:
		return ( pos - p.v1 ) / p.f1;
	default:
		return vec3(1,0,0);
	}
}

struct Intersection
{
	vec3 pos;
	float t;
	vec3 normal;
	int id;
};

Intersection trace( Ray r )
{
	Intersection I = Intersection(vec3(0), MAXLEN, vec3(0), -1);
	for(int i = 0; i < primitives.length(); i++)
	{
		float tI = intersect(r, primitives[i]);
		if( tI > EPSILON && tI < I.t )
		{	
			I.t = tI;
			I.id = i;
		}
	}

	if(I.id == -1) return I;

	I.pos = r.O + I.t * r.D;
	I.normal = getNormal( primitives[I.id], I.pos );

	return I;
}

vec3 DiffuseReflection( vec3 N )
{
	float u = frand();
	float v = frand();
	
	float theta = 2.0f * PI * u;
	float phi = acos(2.0f * v - 1.0f);

	float costheta = cos(theta);
	float sintheta = sin(theta);
	float cosphi = cos(phi);
	float sinphi = sin(phi);

	vec3 R = vec3(costheta * sinphi, sintheta * sinphi, cosphi);
	if(dot(R, N) <= 0.0f)
		R *= -1.0f;

	return R;
}

Ray reflect(Ray r, Intersection I)
{
	return Ray(I.pos, r.n1, r.D + 2.0 * -dot(I.normal, r.D) * I.normal);
}

Ray refract( Primitive p, Ray r, Intersection I )
{
	float R0r = (r.n1 - p.f2) / ( r.n1 + p.f2 );
	float R0 = R0r * R0r;
	float costheta1 = dot(I.normal, -r.D);
	float fr = R0 + ( 1 - R0 ) * pow( 1 - costheta1, 5 );
	if(frand() < fr)
		return reflect(r, I);
	float n12 = r.n1 / p.f2;
	float k = 1 - n12 * n12 * ( 1 - costheta1 * costheta1 );
	if( k < 0 )
		return reflect(r, I);
	return Ray( I.pos, 1 , n12 * r.D + I.normal * ( n12 * costheta1 - sqrt(k) ) );
}

vec3 Sample( Ray r )
{
	vec3 color = WHITE;
	for( int i = MAXBOUNCES; i > 0; i--)
	{	
		Intersection I = trace( r );

		if(I.id == -1)
		{
			color = BLACK;
			break;
		}

		if(primitives[I.id].material == MATERIAL_LIGHT) 
		{	
			color *= primitives[I.id].v2;
			break;
		}

		if(primitives[I.id].material == MATERIAL_SPECULAR)
		{
			r = reflect( r, I );
			color *= primitives[I.id].v2;
			continue;
		}
		if(primitives[I.id].material == MATERIAL_DIELICTRIC)
		{
			r = refract( primitives[I.id], r, I );
			color *= primitives[I.id].v2;//TODO: BEER STUFF
			continue;
		}
		vec3 R = DiffuseReflection( I.normal );
		r = Ray(I.pos, r.n1, R);

		vec3 BRDF = primitives[I.id].v2 / PI;
		color *= PI * 2.0f * BRDF * dot(I.normal, R);
	}
	return color;
}

void main()
{
	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
	state = ubo.seed ^ (ubo.seed * gl_GlobalInvocationID.x * gl_GlobalInvocationID.y);

	Ray r = Ray( ubo.camera.pos, 1, normalize(vec3((-1.0 + 2.0 * uv) * vec2(ubo.aspectRatio, 1.0), -1.0)) );

	vec4 curColor = imageLoad(resultImage, ivec2(gl_GlobalInvocationID.xy));
	vec3 finalColor = Sample(r);
	
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), (vec4(finalColor, 0.0) + (ubo.samples-1) * curColor)/ubo.samples);
}